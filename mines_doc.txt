CODE EXPLANATION

I) Code segments 

- [Start of outer loop] Initialization
0m=87:n=53280:pOn,0:pOn+1,0:v=54296:d=1904:u=1082:?"{clear}{red}mines   {white}use ijkl space"
1t=v-24:fOi=1tod:nE:j=.:?"{clear}":p=1524:o=1143:q=.9:fOi=0to39:pOo-i,102:pOd+i,102:nE

- Generate mines around the player
2...ifrN(0)>qtHx=p-4+2*(int(rN(0)*5))+80*((int(rN(0)*3))-1):pOx,m:pOx+t,1

- [Start of inner/match loop] Handle input for I J K L with a special formula "IJKL double symmetry" (*)
3...:gEa$:s=.:ifa$<>""tHs=aS(a$):e=saN1:y=.
4...c=s-75+e:ifc>-3tHifc<2tHy=1:pOp,m:p=p+c*(39*e+1):...

- Score board + Change player's color to have it flash + Updare record
5...?"{home}  {yellow}$:{white}";9-f;"  {gray}score:{white}";j;"   {dark gray}high score:{white}";r:pOp+t,3:ifj>rtHr=j

- Handle input for " " and its action
6ifa$=" "tHiff<9tHpOn,2:pOp-1,32:pOp+1,32:pOp-40,32:pOp+40,32:f=f+1:pOn,0:pOp,90

- Generate random extra anti-mine charges
7if-ytHifztHg=int(rN(0)*760):pOo+g,w:pOo+g+t,7:ifpE(p)=wtHj=j+4:iff>0tHf=f-1

- Handle player on mine
8...if-ytHq=q-.01:j=j+1:y=.:ifpE(p)=mtH?"{red}boom!!!":fOi=1tod:nE:j=.:f=.:gO0

- Handle player on walls
9...on-(p<daNp>o)gO2:j=.:f=.:?"{red}aargh!!!":fOi=1tod:nE:gO0

The remainig instructions that are not decribed above are primarily:
- preparing some helper variables for the next lines
- poking the video and color ram to display MINES in two alternating colors


II) Some Variables
- p is the position of the player
- x is the position of the mines that appear around the player
- j is the score
- r is the record
- f is the number of used anti-mine charges (9 - number of remaining charges)
- y is a Boolean to detect the player's movement
- q is the probability of a new mine popping up around the player
- d and o describe the positions of the lower and upper border
- t is the difference between the video memory address and the color ram address, i.e., <addr>+t is used to set the color corresponding to the position whose data (not color) is pointed by <addr>


III)  "IJKL double symmetry" formula (*)

I exploit the special symmetry of the ASCII codes of the keys I J K L:
- I and K have odd codes and a distance of 2 bytes
- J and L have even codes and a distance of 2 bytes
- I and K describe positions on the video memory BEFORE the current position
- J and L desrcive positions on the video memory AFTER the current position
So, given s=ASC(a$) with a$ either I or J or K or L, we update the position p with
p=p+c*(39*e+1) 
where
- e=s and 1 -> parity of the code, i.e., vertical vs horizontal movement
- c=s-75+e -> separate before or after in the video memory, i.e., -1 for left/up vs +1 for right/down
- 39e+1 -> vertical vs horizontal offset absolute value, i.e., 1 vs 40 

